#
#Antonio Santos
#CSCI 431 - Final Project 
#4/29/2019
#
import tkinter as tk
import pandas as pd
from tkinter import *
from tkinter import ttk


class FlightProgram:
    def __init__(self):
        self.root = tk.Tk()
        self.root.geometry("800x600")
        self.root.title("CSCI 431 - Antonio Santos Final Project")
        welcomeLabel = ttk.Label(self.root, text="Welcome to my CSCI 431 Final Project!").grid(row=0,column=0)
        self.df = pd.read_csv("ProjectData.csv")
        #by default, show the autogenerated lookup on the front page
        self.generate_preset_table(self.root)
        
        self.filterBtn = ttk.Button(self.root, text = "Filter", 
                command = self.filter).grid(
                        row = 1, column = 0)
        self.root.mainloop()

    def generate_preset_table(self,root):
        #next, cleanse the dataset of rows we dont want
        self.df = self.cleanseData(self.df)

        #next, calculate the flight ranks using my own model to determine what is the best flight. append the flight rank to a success rate column
        df_new = self.calculate_success_rates(self.df)

        #determine best month to travel based on model 
        ranked_months = self.rank_month_performance(df_new)

        #TODO: Fix error below. sorting is not working and i am gtting the lowest value from the list each time.
        top_month = ranked_months.loc[ranked_months['MONTHLY_TOTAL_SUCCESS_RATES'].idxmax()]
        

        #output the result
        l = ttk.Label(root, text="According to our calculations, the best month to take a trip is " + str(int(top_month['MONTH'])) + " with a success rate of " + str(top_month['MONTHLY_TOTAL_SUCCESS_RATES']))
        
        #display the table
        l.grid(row=9,column=0)
        self.insert_table(df_new,root)
 
    
    #TODO: make inert_table function more generic for reuse
    def insert_table(self,df,root):
        frame = tk.Frame(root)
        frame.grid(row=10,column=0)

        #create table columns
        tree = ttk.Treeview(frame, columns = ('Distance','Carrier Name','Origin','Destination','Month','Success Rates'))
        scrolly = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
        scrollx = ttk.Scrollbar(frame, orient="horizontal", command=tree.xview)

        tree.grid(row=10,column=0,sticky=NSEW,pady=(10,0))
        scrolly.grid(row=10,column=1,sticky=NS,pady=(10,0))#pack(side = 'right', fill = 'y')
        scrollx.grid(row=12,column=0,sticky=EW)#pack(side = 'right', fill = 'y')
      
        tree.configure(yscrollcommand=scrolly.set)
        tree.configure(xscrollcommand=scrollx.set)

        #scroll = Scrollbar(root,orient="vertical",command=tree.yview)
        #scroll.grid(row=7,column=5,sticky=NS,pady=(10,0))
        tree.heading('#0', text="Id",anchor=W, command=lambda:self.treeview_sort_column(tree, "Id", False))
        tree.heading('#1', text="Distance", command=lambda:self.treeview_sort_column(tree, "Distance", False))
        tree.heading('#2', text="Carrier Name", command=lambda:self.treeview_sort_column(tree, "Carrier Name", False))
        tree.heading('#3', text="Origin", command=lambda:self.treeview_sort_column(tree, "Origin", False))
        tree.heading('#4', text="Destination", command=lambda:self.treeview_sort_column(tree, "Destination", False))
        tree.heading('#5', text="Month", command=lambda:self.treeview_sort_column(tree, "Month", False))
        tree.heading('#6', text="Success Rates", command=lambda:self.treeview_sort_column(tree, "Success Rates", False))

        tree.column('#0', width = 80)
        tree.column('#1', width = 80)
        tree.column('#2', width = 275)
        tree.column('#3', width = 175)
        tree.column('#4', width = 175)
        tree.column('#5', width = 60)
        tree.column('#6', width = 175)

        for index,row in df.iterrows():
            tree.insert('', 'end', text=index,values = (row['DISTANCE'], row['UNIQUE_CARRIER_NAME'],row['ORIGIN_CITY_NAME'], row['DEST_CITY_NAME'], row['MONTH'], row['SUCCESS_RATES']) )


    def treeview_sort_column(self,tv, col, reverse):
        l = [(tv.set(k, col), k) for k in tv.get_children('')]
        l.sort(reverse=reverse)

        # rearrange items in sorted positions
        for index, (val, k) in enumerate(l):
            tv.move(k, '', index)

        # reverse sort next time
        tv.heading(col, command=lambda: \
                   self.treeview_sort_column(tv, col, not reverse))

    def cleanseData(self,DF):
        DF = DF[DF.CLASS == 'F']    
        DF = DF[DF.SEATS != 0]
        DF = DF[DF.PASSENGERS != 0]
        DF.corr().to_csv("test.csv")
        return DF



    def filter(self):

        # on change dropdown value
        def change_dropdown(event):
            print("New city selected")
 
        choices = self.df['ORIGIN_CITY_NAME'].unique().tolist()
        print(choices)
        labelTop = tk.Label(self.root,
                            text = "Choose Origin City Name")
        labelTop.grid(column=0, row=3)

        comboExample = ttk.Combobox(self.root, 
                                    values=choices)


        comboExample.grid(column=0, row=4)
        comboExample.current(1)

        comboExample.bind("<<ComboboxSelected>>", change_dropdown)
            
    def calculate_success_rates(self,df):
        #Algorithm:
        #1. a) get next row in df 
        #   b) calculate month performance: success rate = DEPARTURES_PERFORMED / DEPARTURES_SCHEDULED
        #   c) append a column called "SUCCESS_RATE" to the row
        #   d) repeat a) unless end of df
        successRates = []
        fillRates = []
        departureSuccessRates = []
        for index,row in df.iterrows(): #range (0, len(df['DISTANCE'])):
            if row['SEATS'] != 0:
                successRate = (1 - (float(row['DEPARTURES_PERFORMED']) / float(row['SEATS']))) * 100
                successRates.append(successRate)

                fillRate = float(row['PASSENGERS']) / float(row['SEATS']) * 100
                fillRates.append(fillRate)
            else:
                successRates.append(0)
                fillRates.append(0)

            if row['DEPARTURES_SCHEDULED'] != 0:
                departureSuccessRate = float(row['DEPARTURES_PERFORMED']) / float(row['DEPARTURES_SCHEDULED'])
                departureSuccessRates.append(departureSuccessRate)
            else:
                departureSuccessRates.append(0)
           
        
        df['SUCCESS_RATES'] = successRates
        df['FILL_RATES'] = fillRates
        df['DEPARTURE_SUCCESS'] = departureSuccessRates    
        df = df.sort_values(by=['SUCCESS_RATES'])
        df.corr().to_csv("corr_successrates.csv")
        df.to_csv("successrates.csv")
        
        return df


    #3. a) sum the DEPARTURES_PERFORNED and DEPARTURES_SCHEDULED columns and group by row
    #   b) calculate total month performance: success rate = DEPARTURES_PERFORMED / DEPARTURES_SCHEDULED
    def rank_month_performance(self,df):
        aggregation_functions = {'SUCCESS_RATES': 'sum','DEPARTURES_PERFORMED': 'sum', 'DEPARTURES_SCHEDULED': 'sum', 'SEATS': 'sum', 'PASSENGERS': 'sum','FILL_RATES':'sum','DEPARTURE_SUCCESS':'sum'}
        df_new = df.groupby(df['MONTH']).aggregate(aggregation_functions).reset_index()

        successRates = []
        for i in range(0,len(df_new['MONTH'])):
            if df_new['DEPARTURES_SCHEDULED'][i] != 0:
                successRate = (1 - (float(df_new['DEPARTURES_PERFORMED'][i]) / float(df_new['SEATS'][i]))) * 100 
                successRates.append(successRate)
            else:
                successRates.append(0.0)
        df_new['MONTHLY_TOTAL_SUCCESS_RATES'] = pd.Series(successRates, dtype=float)
        df_new = df_new.sort_values(by=['MONTHLY_TOTAL_SUCCESS_RATES'], ascending=False)


        #4. run correlations on the dataframe
       # df.corr().to_csv("correlations.csv") 
       # corr = df.corr()
       # slightlyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.5]
       # moderatelyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.7]
       # highlyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.8]
       
       # print("HIGHLY CORR")
       # print(highlyCorrelated)
       # print("-------------------------------")
       # print("MODERATELY CORR")
       # print(moderatelyCorrelated)
       # print("-------------------------------")
       # print("SLIGHTLY CORR")
       # print(slightlyCorrelated)
       # print("-------------------------------")

        return df_new


FlightProgram()
