#
#Antonio Santos
#CSCI 431 - Final Project 
#4/29/2019
#
import tkinter as tk
import pandas as pd
from tkinter import *
from tkinter import ttk


class FlightProgram:
    def __init__(self):
        self.table_row = 17
        self.root = tk.Tk()
        self.root.geometry("1200x800")
        self.root.title("CSCI 431 - Antonio Santos Final Project")
        welcomeLabel = ttk.Label(self.root, text="Welcome to my CSCI 431 Final Project!").grid(row=0,column=0,columnspan=3)
        self.df = pd.read_csv("ProjectData.csv")
        #by default, show the autogenerated lookup on the front page
        self.filtered_df = self.df
        self.dfLeft = self.df
        self.showingCount = 0
        self.leftCount = self.df['DISTANCE'].count()
        #initialize table view
        self.frame = tk.Frame(self.root)
        self.countLabel = Label(self.root, text="Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
        self.resultLabel = ttk.Label(self.root)
        
        self.frame.grid(row=self.table_row,column=0,columnspan=3)
        self.tree = ttk.Treeview(self.frame, columns = ('Distance','Carrier Name','Origin','Destination','Month','Success Rates'))
        #self.countLabel = Label(self.root, text="Showing " + str(self.showingCount) + " out of " + str(self.dfLeft["MONTH"].count())).grid(
        #       row = self.table_row+5, column = 0)
        self.filters = {
            "OCN":"",
            "DCN":"",
            "MON":"",
            "YEA":"",
            "CNA":""
            }

        #populate table
        self.generate_preset_table(self.root)
        
        self.filterBtn = ttk.Button(self.root, text = "Filter", 
                command = self.filter).grid(
                        row = 1, columnspan=3, column = 0)
        self.root.mainloop()

    def generate_preset_table(self,root):
        #next, cleanse the dataset of rows we dont want
        self.df = self.cleanseData(self.df)

        #next, calculate the flight ranks using my own model to determine what is the best flight. append the flight rank to a success rate column
        df_new = self.calculate_success_rates(self.df)

        #determine best month to travel based on model 
        ranked_months = self.rank_month_performance(df_new)

        #TODO: Fix error below. sorting is not working and i am gtting the lowest value from the list each time.
        top_month = ranked_months.loc[ranked_months['MONTHLY_TOTAL_SUCCESS_RATES'].idxmax()]

        
        #display the table
        self.resultLabel['text'] = "According to our calculations, the best month to take a trip is " + str(int(top_month['MONTH'])) + " with a success rate of " + str(top_month['MONTHLY_TOTAL_SUCCESS_RATES'])
        self.resultLabel.grid(row=self.table_row-1,column=0)
        df_new = df_new.sort_values(by=['SUCCESS_RATES'],ascending=True)
        self.insert_table(df_new,root)
 
    
    #TODO: make inert_table function more generic for reuse
    def insert_table(self,df,root):
        
        #create table columns
        scrolly = ttk.Scrollbar(self.frame, orient="vertical", command=self.tree.yview)
        scrollx = ttk.Scrollbar(self.frame, orient="horizontal", command=self.tree.xview)

        self.tree.grid(row=self.table_row,column=0,sticky=NSEW,pady=(10,0))
        scrolly.grid(row=self.table_row,column=4,sticky=NS,pady=(10,0))#pack(side = 'right', fill = 'y')
        scrollx.grid(row=self.table_row+2,column=0,sticky=EW)#pack(side = 'right', fill = 'y')
      
        self.tree.configure(yscrollcommand=scrolly.set)
        self.tree.configure(xscrollcommand=scrollx.set)

        #scroll = Scrollbar(root,orient="vertical",command=self.tree.yview)
        #scroll.grid(row=7,column=5,sticky=NS,pady=(10,0))
        self.tree.heading('#0', text="Id",anchor=W, command=lambda:self.treeview_sort_column(self.tree, "Id", False))
        self.tree.heading('#1', text="Distance", command=lambda:self.treeview_sort_column(self.tree, "Distance", False))
        self.tree.heading('#2', text="Carrier Name", command=lambda:self.treeview_sort_column(self.tree, "Carrier Name", False))
        self.tree.heading('#3', text="Origin", command=lambda:self.treeview_sort_column(self.tree, "Origin", False))
        self.tree.heading('#4', text="Destination", command=lambda:self.treeview_sort_column(self.tree, "Destination", False))
        self.tree.heading('#5', text="Month", command=lambda:self.treeview_sort_column(self.tree, "Month", False))
        self.tree.heading('#6', text="Success Rates", command=lambda:self.treeview_sort_column(self.tree, "Success Rates", False))

        self.tree.column('#0', width = 80)
        self.tree.column('#1', width = 80)
        self.tree.column('#2', width = 275)
        self.tree.column('#3', width = 175)
        self.tree.column('#4', width = 175)
        self.tree.column('#5', width = 60)
        self.tree.column('#6', width = 175)
        
        limit = 50 
        i = 0
        df = df.sort_values(by=['SUCCESS_RATES'],ascending=False)
        self.dfLeft = df
        for index,row in df.iterrows():
            self.tree.insert('', 'end', text=index,values = (row['DISTANCE'], row['UNIQUE_CARRIER_NAME'],row['ORIGIN_CITY_NAME'], row['DEST_CITY_NAME'], row['MONTH'], row['SUCCESS_RATES']) )
            self.dfLeft = self.dfLeft.drop(index)
            i=i+1
            self.showingCount = self.showingCount + 1
            if(i == limit):
                break
        self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
        

        def showNext50Rows():
            limit = 50 
            i = 0
            dfLeftTemp = self.dfLeft
            for index,row in self.dfLeft.iterrows():
                self.tree.insert('', 'end', text=index,values = (row['DISTANCE'], row['UNIQUE_CARRIER_NAME'],row['ORIGIN_CITY_NAME'], row['DEST_CITY_NAME'], row['MONTH'], row['SUCCESS_RATES']) )
                dfLeftTemp = dfLeftTemp.drop(index)

                i = i+1
                self.showingCount = self.showingCount + 1
                if(i == limit):
                    #self.dfLeft = dfLeftTemp
                    #print(self.dfLeft)
                    break
            self.dfLeft = dfLeftTemp
            self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))

        
        showNext50RowsBtn = ttk.Button(self.root, text = "Next 50", 
                command = showNext50Rows).grid(
                        row = self.table_row+4,columnspan=3, column = 1)

#        countLabel = Label(self.root, text="Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
        self.countLabel.grid(row = self.table_row+5,columnspan=3, column = 1)



    def treeview_sort_column(self,tv, col, reverse):
        l = [(tv.set(k, col), k) for k in tv.get_children('')]
        l.sort(reverse=reverse)

        # rearrange items in sorted positions
        for index, (val, k) in enumerate(l):
            tv.move(k, '', index)

        # reverse sort next time
        tv.heading(col, command=lambda: \
                   self.treeview_sort_column(tv, col, not reverse))

    def cleanseData(self,DF):
        DF = DF[DF.CLASS == 'F']    
        DF = DF[DF.SEATS != 0]
        DF = DF[DF.PASSENGERS != 0]
        DF.corr().to_csv("test.csv")
        return DF

    def filter(self):
        originCityNamesList = self.filtered_df['ORIGIN_CITY_NAME'].unique().tolist()
        destCityNamesList = self.filtered_df['DEST_CITY_NAME'].unique().tolist()
        monthsList = self.filtered_df['MONTH'].unique().tolist()
        yearsList = self.filtered_df['YEAR'].unique().tolist()
        carrierNamesList = self.filtered_df['UNIQUE_CARRIER_NAME'].unique().tolist()
        distancesList = ['0-99','100-199','200-299','300-399','400-499','500-999','1000-1499','1500-1999','2000-2499','2500-2999','3000+']
        def filterOriginCityName(event):
            print("sorting by origin city name...")
            self.filtered_df = self.filtered_df.loc[self.filtered_df['ORIGIN_CITY_NAME'] == originCityNames.get()]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)
        
        def filterDestCityName(event):
            print("sorting by destination city name...")
            self.filtered_df = self.filtered_df.loc[self.filtered_df['DEST_CITY_NAME'] == destinationCityNames.get()]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)


        def filterMonth(event):
            print("sorting by month...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['MONTH'] == months.get()]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)

        
        def filterYear(event):
            print("sorting by year...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['YEAR'] == int(years.get())]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)

        
        def filterCarrierName(event):
            print("sorting by carrier name...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['UNIQUE_CARRIER_NAME'] == carrierNames.get()]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)


        def filterDistance(event):
            print("sorting by distance...")
            distance = distances.get()
            if(distance == '3000+'):
                self.filtered_df = self.df.loc[self.df['DISTANCE'] > 3000]
            else:
                dRange = map(int,distance.split("-", 1))
                print(dRange)
                self.filtered_df = self.df.loc[self.df['DISTANCE'].isin(dRange)]
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)

        
        def updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances):
            self.showingCount = 0
            self.leftCount = self.filtered_df['DISTANCE'].count()
            self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))

            
            print("------------------------------------------------------------------\nupdating lists...")
            originCityNamesList = self.filtered_df['ORIGIN_CITY_NAME'].unique().tolist()
            destCityNamesList = self.filtered_df['DEST_CITY_NAME'].unique().tolist()
            monthsList = self.filtered_df['MONTH'].unique().tolist()
            yearsList = self.filtered_df['YEAR'].unique().tolist()
            carrierNamesList = self.filtered_df['UNIQUE_CARRIER_NAME'].unique().tolist()
            
            print(originCityNamesList)
            print(destCityNamesList)
            print(monthsList)
            print(yearsList)
            print(carrierNamesList)
            print("-----------------------------------------------------------------------")
            
            #update lists in combobox's
            originCityNames['values'] = originCityNamesList
            destinationCityNames['values'] = destCityNamesList
            months['values'] = monthsList
            years['values'] = yearsList
            carrierNames['values'] = carrierNamesList
            distances['values'] = distancesList
           

            self.tree.delete(*self.tree.get_children())


            #next, cleanse the dataset of rows we dont want
            self.filtered_df = self.cleanseData(self.filtered_df)

            if(self.filtered_df.empty == False):
                #next, calculate the flight ranks using my own model to determine what is the best flight. append the flight rank to a success rate column
                filtered_df_new = self.calculate_success_rates(self.filtered_df)

                #determine best month to travel based on model 
                ranked_months = self.rank_month_performance(filtered_df_new)

                top_month = ranked_months.loc[ranked_months['MONTHLY_TOTAL_SUCCESS_RATES'].idxmax()]

                #output the result
                self.resultLabel['text'] = "According to our calculations, the best month to take a trip is " + str(int(top_month['MONTH'])) + " with a success rate of " + str(top_month['MONTHLY_TOTAL_SUCCESS_RATES'])
                filtered_df_new.sort_values(by=['SUCCESS_RATES'])
                self.insert_table(filtered_df_new,self.root)
                
            else:
                print(self.filtered_df.count())
                self.resultLabel['text'] = "No results"
                self.insert_table(self.filtered_df,self.root)
                

            
        def resetSearch():
            self.showingCount = 0
            self.leftCount = self.df['DISTANCE'].count()
            self.filtered_df = self.df
            updateLists(originCityNames,destinationCityNames,months,years,carrierNames,distances)

            #reset what is being pointed at to be the default first value
            originCityNames.set('')
            destinationCityNames.set('')
            months.set('')
            years.set('')
            carrierNames.set('')
            distances.set('')

        print(originCityNamesList)
        print(destCityNamesList)
        print(monthsList)
        print(yearsList)
        print(carrierNamesList)
        print(distancesList)
        

#DISTANCES 
        distanceLabel = tk.Label(self.root,text = "Travel Distance").grid(columnspan=3,column=0, row=self.table_row-14)
        distances = ttk.Combobox(self.root, values=distancesList)
        distances.grid(columnspan=3,column=0, row=self.table_row-13)
        distances.bind("<<ComboboxSelected>>", filterDistance)

#ORIGIN CITY NAMES
        originCityNamesLabel = tk.Label(self.root, text = "Choose Origin City Name").grid(columnspan=3,column=0, row=self.table_row-12)
        originCityNames = ttk.Combobox(self.root, values=originCityNamesList)
        originCityNames.grid(columnspan=3,column=0, row=self.table_row-11)
        originCityNames.bind("<<ComboboxSelected>>", filterOriginCityName)

#DEST CITY NAMES
        destinationCityNamesLabel = tk.Label(self.root, text = "Choose Destination City Name").grid(columnspan=3,column=0, row=self.table_row-10)
        destinationCityNames = ttk.Combobox(self.root, values=destCityNamesList)
        destinationCityNames.grid(columnspan=3,column=0, row=self.table_row-9)
        destinationCityNames.bind("<<ComboboxSelected>>", filterDestCityName)

#MONTHS
        monthsLabel = tk.Label(self.root,text = "Choose Month").grid(columnspan=3,column=0, row=self.table_row-8)
        months = ttk.Combobox(self.root, values=monthsList)
        months.grid(columnspan=3,column=0, row=self.table_row-7)
        months.bind("<<ComboboxSelected>>", filterMonth)

#YEARS
        yearsLabel = tk.Label(self.root,text = "Choose Year").grid(columnspan=3,column=0, row=self.table_row-6)
        years = ttk.Combobox(self.root, values=yearsList)
        years.grid(columnspan=3,column=0, row=self.table_row-5)
        years.bind("<<ComboboxSelected>>", filterYear)

#CARRIER NAME
        carrierNamesLabel = tk.Label(self.root,text = "Choose Carrier Name").grid(columnspan=3,column=0, row=self.table_row-4)
        carrierNames = ttk.Combobox(self.root, values=carrierNamesList)
        carrierNames.grid(columnspan=3,column=0, row=self.table_row-3)
        carrierNames.bind("<<ComboboxSelected>>", filterCarrierName)

        self.submitFilters = ttk.Button(self.root, text = "Reset", 
                command = resetSearch).grid(
                        row = self.table_row-2, column = 0,columnspan=3)


    def calculate_success_rates(self,df):
        #Algorithm:
        #1. a) get next row in df 
        #   b) calculate month performance: success rate = DEPARTURES_PERFORMED / DEPARTURES_SCHEDULED
        #   c) append a column called "SUCCESS_RATE" to the row
        #   d) repeat a) unless end of df
        successRates = []
        fillRates = []
        departureSuccessRates = []
        for index,row in df.iterrows(): #range (0, len(df['DISTANCE'])):
            if row['SEATS'] != 0:
                successRate = (1 - (float(row['DEPARTURES_PERFORMED']) / float(row['SEATS']))) * 100
                successRates.append(successRate)

                fillRate = float(row['PASSENGERS']) / float(row['SEATS']) * 100
                fillRates.append(fillRate)
            else:
                successRates.append(0)
                fillRates.append(0)

            if row['DEPARTURES_SCHEDULED'] != 0:
                departureSuccessRate = float(row['DEPARTURES_PERFORMED']) / float(row['DEPARTURES_SCHEDULED'])
                departureSuccessRates.append(departureSuccessRate)
            else:
                departureSuccessRates.append(0)
           
        
        df['SUCCESS_RATES'] = successRates
        df['FILL_RATES'] = fillRates
        df['DEPARTURE_SUCCESS'] = departureSuccessRates    
        df = df.sort_values(by=['SUCCESS_RATES'])
        df.corr().to_csv("corr_successrates.csv")
        df.to_csv("successrates.csv")
        
        return df


    #3. a) sum the DEPARTURES_PERFORNED and DEPARTURES_SCHEDULED columns and group by row
    #   b) calculate total month performance: success rate = DEPARTURES_PERFORMED / DEPARTURES_SCHEDULED
    def rank_month_performance(self,df):
        aggregation_functions = {'SUCCESS_RATES': 'sum','DEPARTURES_PERFORMED': 'sum', 'DEPARTURES_SCHEDULED': 'sum', 'SEATS': 'sum', 'PASSENGERS': 'sum','FILL_RATES':'sum','DEPARTURE_SUCCESS':'sum'}
        df_new = df.groupby(df['MONTH']).aggregate(aggregation_functions).reset_index()

        successRates = []
        for i in range(0,len(df_new['MONTH'])):
            if df_new['DEPARTURES_SCHEDULED'][i] != 0:
                successRate = (1 - (float(df_new['DEPARTURES_PERFORMED'][i]) / float(df_new['SEATS'][i]))) * 100 
                successRates.append(successRate)
            else:
                successRates.append(0.0)
        df_new['MONTHLY_TOTAL_SUCCESS_RATES'] = pd.Series(successRates, dtype=float)
        df_new = df_new.sort_values(by=['MONTHLY_TOTAL_SUCCESS_RATES'], ascending=False)


        #4. run correlations on the dataframe
       # df.corr().to_csv("correlations.csv") 
       # corr = df.corr()
       # slightlyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.5]
       # moderatelyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.7]
       # highlyCorrelated = corr.loc[corr['SUCCESS_RATES'] >= 0.8]
       
       # print("HIGHLY CORR")
       # print(highlyCorrelated)
       # print("-------------------------------")
       # print("MODERATELY CORR")
       # print(moderatelyCorrelated)
       # print("-------------------------------")
       # print("SLIGHTLY CORR")
       # print(slightlyCorrelated)
       # print("-------------------------------")

        return df_new


FlightProgram()
