#
#Antonio Santos
#CSCI 431 - Final Project 
#4/29/2019
#
import tkinter as tk
import pandas as pd
from tkinter import *
from tkinter import ttk


class FlightProgram:
    def __init__(self):
        self.table_row = 23
        self.columnspan = 10
        self.root = tk.Tk()
        self.root.geometry("1200x800")
        self.root.title("CSCI 431 - Antonio Santos Final Project")
        welcomeLabel = ttk.Label(self.root, text="Flight Finder Application").grid(row=0,column=round(self.columnspan/2))
        #self.df = pd.read_csv("ProjectData.csv")
        self.df = self.engineerData()        
        #by default, show the autogenerated lookup on the front page
        self.filtered_df = self.df
        self.dfLeft = self.df
        self.showingCount = 0
        self.leftCount = self.df['DISTANCE'].count()
        #initialize table view
        self.frame = tk.Frame(self.root)
        self.countLabel = Label(self.root, text="Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
        self.resultLabel = ttk.Label(self.root)
        
        self.frame.grid(row=self.table_row,column=1,columnspan=self.columnspan)
        self.tree = ttk.Treeview(self.frame, columns = ('Origin','Destination','Carrier Name','Aircraft','Distance','Month','Seats Available','Flight Success Rate'))

        #populate table
        self.generate_preset_table(self.root)
        
        self.filterBtn = ttk.Button(self.root, text = "Filter", 
                command = self.filter).grid(
                        row = 1, column = round(self.columnspan/2))
        self.root.mainloop()

    def generate_preset_table(self,root):

        #determine best month to travel based on model 
        top_month = self.calculateTopMonth(self.df)

        #display the table
        self.resultLabel['text'] = "According to our calculations, the best month to take a trip is " + str(top_month['MONTH']) + " with a success rate of " + str(top_month['MONTHLY_TOTAL_RANKS'])
        self.resultLabel.grid(row=self.table_row-1,column=round(self.columnspan/2))
        df_new = self.df.sort_values(by=['RANKS'],ascending=True)
        self.insert_table(df_new,root)
 
    
    #TODO: make inert_table function more generic for reuse
    def insert_table(self,df,root):
        
        #create table columns
        scrolly = ttk.Scrollbar(self.frame, orient="vertical", command=self.tree.yview)
        scrollx = ttk.Scrollbar(self.frame, orient="horizontal", command=self.tree.xview)

        self.tree.grid(row=self.table_row,column=0,sticky=NSEW,pady=(10,0))
        scrolly.grid(row=self.table_row,column=self.columnspan+1,sticky=NS,pady=(10,0))#pack(side = 'right', fill = 'y')
        scrollx.grid(row=self.table_row+2,column=0,sticky=EW)#pack(side = 'right', fill = 'y')
      
        self.tree.configure(yscrollcommand=scrolly.set)
        self.tree.configure(xscrollcommand=scrollx.set)

        #scroll = Scrollbar(root,orient="vertical",command=self.tree.yview)
        #scroll.grid(row=7,column=5,sticky=NS,pady=(10,0))
       # self.tree.heading('#0', text="",anchor=W, command=lambda:self.treeview_sort_column(self.tree, "", False))        
        self.tree.heading('#1', text="Origin", command=lambda:self.treeview_sort_column(self.tree, "Origin", False))
        self.tree.heading('#2', text="Destination", command=lambda:self.treeview_sort_column(self.tree, "Destination", False))
        self.tree.heading('#3', text="Carrier Name", command=lambda:self.treeview_sort_column(self.tree, "Carrier", False))
        self.tree.heading('#4', text="Aircraft", command=lambda:self.treeview_sort_column(self.tree, "Aircraft", False))        
        self.tree.heading('#5', text="Distance", command=lambda:self.treeview_sort_column(self.tree, "Distance", False))
        self.tree.heading('#6', text="Month", command=lambda:self.treeview_sort_column(self.tree, "Month", False))
        self.tree.heading('#7', text="Seats Available", command=lambda:self.treeview_sort_column(self.tree, "Seats Available", False))
        self.tree.heading('#8', text="Flight Success Rate", command=lambda:self.treeview_sort_column(self.tree, "Flight Success Rate", False))
        self.tree['show'] = 'headings'
        #set the column widths for each column
       # self.tree.column('#0', width = 0)
        self.tree.column('#1', width = 285)
        self.tree.column('#2', width = 285)
        self.tree.column('#3', width = 200)
        self.tree.column('#4', width = 285)
        self.tree.column('#5', width = 100)
        self.tree.column('#6', width = 100)
        self.tree.column('#7', width = 100)
        self.tree.column('#8', width = 100)
        
        limit = 50 
        i = 0
        df = df.sort_values(by=['RANKS'],ascending=False)
        self.dfLeft = df
        for index,row in df.iterrows():
            if((row['SEATS'] - row['PASSENGERS']) != 0):
                self.tree.insert('', 'end', text=index,values = (row['ORIGIN_CITY_NAME'], row['DEST_CITY_NAME'],row['UNIQUE_CARRIER_NAME'],row['AIRCRAFT'], str(row['DISTANCE']) + " miles", row['MONTH'], str(row['SEATS'] - row['PASSENGERS']),str(row['DEPARTURE_SUCCESS']*100) + "%"))
                self.dfLeft = self.dfLeft.drop(index)
                i=i+1
                self.showingCount = self.showingCount + 1
                if(i == limit):
                    break
        self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
        

        def showNext50Rows():
            limit = 50 
            i = 0
            dfLeftTemp = self.dfLeft
            for index,row in self.dfLeft.iterrows():
                self.tree.insert('', 'end', text=index,values = (row['ORIGIN_CITY_NAME'], row['DEST_CITY_NAME'],row['UNIQUE_CARRIER_NAME'],row['AIRCRAFT'], str(row['DISTANCE']) + " miles", row['MONTH'], str(row['SEATS'] - row['PASSENGERS']),str(row['DEPARTURE_SUCCESS']*100) + "%"))

                dfLeftTemp = dfLeftTemp.drop(index)

                i = i+1
                self.showingCount = self.showingCount + 1
                if(i == limit):
                    break
            self.dfLeft = dfLeftTemp
            self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))

        
        showNext50RowsBtn = ttk.Button(self.root, text = "Next 50", 
                command = showNext50Rows).grid(
                        row = self.table_row+4,column = round(self.columnspan/2))

        self.countLabel.grid(row = self.table_row+5,column = round(self.columnspan/2))



    def treeview_sort_column(self,tv, col, reverse):
        l = [(tv.set(k, col), k) for k in tv.get_children('')]
        l.sort(reverse=reverse)

        # rearrange items in sorted positions
        for index, (val, k) in enumerate(l):
            tv.move(k, '', index)

        # reverse sort next time
        tv.heading(col, command=lambda: \
                   self.treeview_sort_column(tv, col, not reverse))



    def filter(self):
        originCityNamesList = self.filtered_df['ORIGIN_CITY_NAME'].unique().tolist()
        originStateNamesList = self.filtered_df['ORIGIN_STATE_NM'].unique().tolist()
        destCityNamesList = self.filtered_df['DEST_CITY_NAME'].unique().tolist()
        destStateNamesList = self.filtered_df['DEST_STATE_NM'].unique().tolist()
        monthsList = self.filtered_df['MONTH'].unique().tolist()
        yearsList = self.filtered_df['YEAR'].unique().tolist()
        carrierNamesList = self.filtered_df['UNIQUE_CARRIER_NAME'].unique().tolist()
        aircraftNamesList = self.filtered_df['AIRCRAFT'].unique().tolist()
        distancesList = ['0-99','100-199','200-299','300-399','400-499','500-999','1000-1499','1500-1999','2000-2499','2500-2999','3000+']


        print(originCityNamesList)
        print(originStateNamesList)
        print(destCityNamesList)
        print(destStateNamesList)
        print(monthsList)
        print(yearsList)
        print(carrierNamesList)
        print(aircraftNamesList)
        print(distancesList)


##HELPER FUNCTIONS FOR FILTERS
        def filterOriginCityName(event):
            print("sorting by origin city name...")
            #first, find all rows that match filtered criteria from dataframe
            self.filtered_df = self.filtered_df.loc[self.filtered_df['ORIGIN_CITY_NAME'] == originCityNames.get()]
            #then, update the lists with the newly filtered dataframe
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterOriginStateName(event):
            print("sorting by origin state name...")
            self.filtered_df = self.filtered_df.loc[self.filtered_df['ORIGIN_STATE_NM'] == originStateNames.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterDestCityName(event):
            print("sorting by destination city name...")
            self.filtered_df = self.filtered_df.loc[self.filtered_df['DEST_CITY_NAME'] == destinationCityNames.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterDestStateName(event):
            print("sorting by destination state name...")
            self.filtered_df = self.filtered_df.loc[self.filtered_df['DEST_STATE_NM'] == destinationStateNames.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterMonth(event):
            print("sorting by month...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['MONTH'] == months.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterYear(event):
            print("sorting by year...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['YEAR'] == years.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterCarrierName(event):
            print("sorting by carrier name...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['UNIQUE_CARRIER_NAME'] == carrierNames.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterAircraftName(event):
            print("sorting by aircraft name...")            
            self.filtered_df = self.filtered_df.loc[self.filtered_df['AIRCRAFT'] == aircraftNames.get()]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)
        def filterDistance(event):
            print("sorting by distance...")
            #get user choice
            distance = distances.get()
            if(distance == '3000+'):
                self.filtered_df = self.filtered_df.loc[self.filtered_df['DISTANCE'] > 3000]
            else:
                #left side of '-' represents time from, left hand side represents time to. we dont have this convention with '300+', hence the if else 
                dRange = map(int,distance.split("-", 1))
                self.filtered_df = self.filtered_df.loc[self.filtered_df['DISTANCE'].isin(dRange)]
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)

        
        def updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances):
            #first, update counters
            self.showingCount = 0
            self.leftCount = self.filtered_df['DISTANCE'].count()
            #and text
            self.countLabel.config(text = "Showing " + str(self.showingCount) + " out of " + str(self.leftCount))
            
            #update the lists elements 
            originCityNamesList = self.filtered_df['ORIGIN_CITY_NAME'].unique().tolist()
            originStateNamesList = self.filtered_df['ORIGIN_STATE_NM'].unique().tolist()
            destCityNamesList = self.filtered_df['DEST_CITY_NAME'].unique().tolist()
            destStateNamesList = self.filtered_df['DEST_STATE_NM'].unique().tolist()
            monthsList = self.filtered_df['MONTH'].unique().tolist()
            yearsList = self.filtered_df['YEAR'].unique().tolist()
            carrierNamesList = self.filtered_df['UNIQUE_CARRIER_NAME'].unique().tolist()
            aircraftNamesList = self.filtered_df['AIRCRAFT'].unique().tolist()

            #used for validation testing - remove when done
            print("------------------------------------------------------------------\nupdating lists...")            
            print(originCityNamesList)
            print(originStateNamesList)
            print(destCityNamesList)
            print(destStateNamesList)
            print(monthsList)
            print(yearsList)
            print(carrierNamesList)
            print(aircraftNamesList)
            print("-----------------------------------------------------------------------")
            
            #update lists in combobox's
            originCityNames['values'] = originCityNamesList
            originStateNames['values'] = originStateNamesList
            destinationCityNames['values'] = destCityNamesList
            destinationStateNames['values'] = destStateNamesList
            months['values'] = monthsList
            years['values'] = yearsList
            carrierNames['values'] = carrierNamesList
            aircraftNames['values'] = aircraftNamesList
            distances['values'] = distancesList
            
            #delete everything from tree/table
            self.tree.delete(*self.tree.get_children())

            if(self.filtered_df.empty == False):
                #next, calculate the flight ranks using my own model to determine what is the best flight. append the flight rank to a success rate column
                filtered_df_new = self.calculateRanks(self.filtered_df)

                #determine best month to travel based on model 
                ranked_months = self.calculateRanks(filtered_df_new)

                top_month = self.calculateTopMonth(ranked_months)

                #output the result
                self.resultLabel['text'] = "According to our calculations, the best month to take a trip is " + str(top_month['MONTH']) + " with a success rate of " + str(top_month['MONTHLY_TOTAL_RANKS'])
                filtered_df_new.sort_values(by=['RANKS'])
                self.insert_table(filtered_df_new,self.root)
                
            else:
                self.resultLabel['text'] = "No results"
                self.insert_table(self.filtered_df,self.root)
                
        def resetSearch():
            self.showingCount = 0
            self.leftCount = self.df['DISTANCE'].count()
            self.filtered_df = self.df
            updateLists(originCityNames,originStateNames,destinationCityNames,destinationStateNames,months,years,carrierNames,aircraftNames,distances)

            #reset what is being pointed at to be the default first value
            originCityNames.set('')
            originStateNames.set('')
            destinationStateNames.set('')
            destinationStateNames.set('')
            months.set('')
            years.set('')
            carrierNames.set('')
            aircraftNames.set('')
            distances.set('')
        
#DISTANCES 
        distanceLabel = tk.Label(self.root,text = "Travel Distance").grid(column=4, row=self.table_row-8)
        distances = ttk.Combobox(self.root, values=distancesList)
        distances.grid(column=4, row=self.table_row-7)
        distances.bind("<<ComboboxSelected>>", filterDistance)

#ORIGIN CITY NAMES
        originCityNamesLabel = tk.Label(self.root, text = "Choose Origin City Name").grid(column=4, row=self.table_row-6)
        originCityNames = ttk.Combobox(self.root, values=originCityNamesList)
        originCityNames.grid(column=4, row=self.table_row-5)
        originCityNames.bind("<<ComboboxSelected>>", filterOriginCityName)

#ORIGIN STATE NAMES
        originStateNamesLabel = tk.Label(self.root, text = "Choose Origin State Name").grid(column=4, row=self.table_row-4)
        originStateNames = ttk.Combobox(self.root, values=originStateNamesList)
        originStateNames.grid(column=4, row=self.table_row-3)
        originStateNames.bind("<<ComboboxSelected>>", filterOriginStateName)

#DEST CITY NAMES
        destinationCityNamesLabel = tk.Label(self.root, text = "Choose Destination City Name").grid(column=5, row=self.table_row-8)
        destinationCityNames = ttk.Combobox(self.root, values=destCityNamesList)
        destinationCityNames.grid(column=5, row=self.table_row-7)
        destinationCityNames.bind("<<ComboboxSelected>>", filterDestCityName)

#DEST STATE NAMES
        destinationStateNamesLabel = tk.Label(self.root, text = "Choose Destination State Name").grid(column=5, row=self.table_row-6)
        destinationStateNames = ttk.Combobox(self.root, values=destStateNamesList)
        destinationStateNames.grid(column=5, row=self.table_row-5)
        destinationStateNames.bind("<<ComboboxSelected>>", filterDestStateName)

#MONTHS
        monthsLabel = tk.Label(self.root,text = "Choose Month").grid(column=5, row=self.table_row-4)
        months = ttk.Combobox(self.root, values=monthsList)
        months.grid(column=5, row=self.table_row-3)
        months.bind("<<ComboboxSelected>>", filterMonth)

#YEARS
        yearsLabel = tk.Label(self.root,text = "Choose Year").grid(column=6, row=self.table_row-8)
        years = ttk.Combobox(self.root, values=yearsList)
        years.grid(column=6, row=self.table_row-7)
        years.bind("<<ComboboxSelected>>", filterYear)

#CARRIER NAME
        carrierNamesLabel = tk.Label(self.root,text = "Choose Carrier Name").grid(column=6, row=self.table_row-6)
        carrierNames = ttk.Combobox(self.root, values=carrierNamesList)
        carrierNames.grid(column=6, row=self.table_row-5)
        carrierNames.bind("<<ComboboxSelected>>", filterCarrierName)

#AIRCRAFT NAME
        aircraftNamesLabel = tk.Label(self.root,text = "Choose Aircraft Name").grid(column=6, row=self.table_row-4)
        aircraftNames = ttk.Combobox(self.root, values=aircraftNamesList)
        aircraftNames.grid(column=6, row=self.table_row-3)
        aircraftNames.bind("<<ComboboxSelected>>", filterAircraftName)

        #button to reset filters back to normal state
        self.submitFilters = ttk.Button(self.root, text = "Reset", 
                command = resetSearch).grid(
                        row = self.table_row-2, column = round(self.columnspan/2))


    def calculateRanks(self,df):
        ranks = []
        fillRates = []
        departureSuccessRates = []
        for index,row in df.iterrows(): #range (0, len(df['DISTANCE'])):
            if (row['SEATS'] != 0) and (row['DEPARTURES_SCHEDULED'] != 0):
#CALCULATE RANK
                #to keep scores at <= 100, we first check to make sure no "overperformance" happened
                #first check is to see if the flights success rate is > 100 and the current capacity is not over flowed
                if (float(row['DEPARTURES_PERFORMED']) > float(row['DEPARTURES_SCHEDULED'])) and (float(row['PASSENGERS']) > float(row['SEATS'])):
                    #if the capacity for the flight is > how much the flight can hold, then the chances of it being a successful flight for our client is slim
                    rank = 0 
                elif float(row['DEPARTURES_PERFORMED']) > float(row['DEPARTURES_SCHEDULED']):
                    #in the case that the flight is overperforming, we count this as a 100% success rate for the flight 
                    rank = 100 * (.75 + .25 * (float(row['PASSENGERS']) / float(row['SEATS'])))
                elif float(row['PASSENGERS']) > float(row['SEATS']):
                    #if the capacity for the flight is > how much the flight can hold, then the chances of it being a successful flight for our client is slim
                    rank = 0
                else:
                    #no "overperformance" occured
                    rank = 100 * (.75 * (float(row['DEPARTURES_PERFORMED']) / float(row['DEPARTURES_SCHEDULED'])) + .25 * (float(row['PASSENGERS']) / float(row['SEATS'])))
                ranks.append(rank)

#CALCULATE FILL RATE
                fillRate = float(row['PASSENGERS']) / float(row['SEATS']) * 100
                fillRates.append(fillRate)

#CALCULATE FLIGHT SUCCESS RATE
                departureSuccessRate = float(row['DEPARTURES_PERFORMED']) / float(row['DEPARTURES_SCHEDULED'])
                departureSuccessRates.append(departureSuccessRate)

            else:
                ranks.append(0)
                fillRates.append(0)
                departureSuccessRates.append(0)

             
        df['RANKS'] = ranks 
        df['FILL_RATES'] = fillRates
        df['DEPARTURE_SUCCESS'] = departureSuccessRates    
        df = df.sort_values(by=['RANKS'])
        return df


    def calculateTopMonth(self,df):
        #to calculate the ranks for each month, we first have to sum each row used in the calculation and group them all by month
        aggregation_functions = {'RANKS': 'sum','DEPARTURES_PERFORMED': 'sum', 'DEPARTURES_SCHEDULED': 'sum', 'SEATS': 'sum', 'PASSENGERS': 'sum','FILL_RATES':'sum','DEPARTURE_SUCCESS':'sum'}
        df_new = df.groupby(df['MONTH']).aggregate(aggregation_functions).reset_index()

        ranks = []
        for index,row in df_new.iterrows():
            #for the calculation to not fail, we need to check if there are any seats or any scheduled departures
            if (row['SEATS'] != 0) and (row['DEPARTURES_SCHEDULED'] != 0):
                #to keep scores at <= 100, we first check to make sure no "overperformance" happened
                #first check is to see if the flights success rate is > 100 and the current capacity is not over flowed
                if (float(row['DEPARTURES_PERFORMED']) > float(row['DEPARTURES_SCHEDULED'])) and (float(row['PASSENGERS']) > float(row['SEATS'])):
                    #if the capacity for the flight is > how much the flight can hold, then the chances of it being a successful flight for our client is slim
                    rank = 0 
                elif float(row['DEPARTURES_PERFORMED']) > float(row['DEPARTURES_SCHEDULED']):
                    #in the case that the flight is overperforming, we count this as a 100% success rate for the flight 
                    rank = 100 * (.75 + .25 * (float(row['PASSENGERS']) / float(row['SEATS'])))
                elif float(row['PASSENGERS']) > float(row['SEATS']):
                    #if the capacity for the flight is > how much the flight can hold, then the chances of it being a successful flight for our client is slim
                    rank = 0
                else:
                    #no "overperformance" occured
                    rank = 100 * (.75 * (float(row['DEPARTURES_PERFORMED']) / float(row['DEPARTURES_SCHEDULED'])) + .25 * (float(row['PASSENGERS']) / float(row['SEATS'])))
                ranks.append(rank)

            #if there is either no seats or no scheduled departures, then the rank is 0 for this flight
            else:
                ranks.append(0.0) 

        df_new['MONTHLY_TOTAL_RANKS'] = pd.Series(ranks, dtype=float)
        top_month = df_new.loc[df_new['MONTHLY_TOTAL_RANKS'].idxmax()]
        return top_month

    def engineerData(self):
        df = pd.read_csv("ProjectData.csv")
        df = df[df.CLASS == 'F']    
        df = df[['DEPARTURES_SCHEDULED','DEPARTURES_PERFORMED','SEATS','PASSENGERS','DISTANCE','UNIQUE_CARRIER_NAME','ORIGIN_CITY_NAME','ORIGIN_STATE_NM','DEST_CITY_NAME','DEST_STATE_NM','AIRCRAFT_TYPE','MONTH','YEAR','CLASS']]
        df = df[df.SEATS != 0]
        df = df[df.PASSENGERS != 0]
        
        
        aircraftLookup = pd.read_csv("L_AIRCRAFT_TYPE.csv")
        aircrafts = []
        months = []
        aircraft = ""
        for index,row in df.iterrows():
            #add on the aircraft by first getting the aircraft code from the project data source and finding the corresponding
            #aircraft name using a lookup table
            if df['AIRCRAFT_TYPE'][index] != 0:
                aircraftObj = aircraftLookup.loc[aircraftLookup['Code'] == df['AIRCRAFT_TYPE'][index]].Description
                for val in aircraftObj:
                    aircraft = str(val)
                aircrafts.append(aircraft)
            else:
                aircrafts.append("Nan")
            
            #change the month value to say the current month value and not just the number
            if df['MONTH'][index] == 1:
                month = "January"
            elif df['MONTH'][index] == 2:
                month = "February"
            elif df['MONTH'][index] == 3:
                month = "March"
            elif df['MONTH'][index] == 4:
                month = "April"
            elif df['MONTH'][index] == 5:
                month = "May"
            elif df['MONTH'][index] == 6:
                month = "June"
            elif df['MONTH'][index] == 7:
                month = "July"
            elif df['MONTH'][index] == 8:
                month = "August"
            elif df['MONTH'][index] == 9:
                month = "September"
            elif df['MONTH'][index] == 10:
                month = "October"
            elif df['MONTH'][index] == 11:
                month = "November"
            elif df['MONTH'][index] == 12:
                month = "December"

            months.append(month)

        print(aircrafts)
        df['AIRCRAFT'] = aircrafts
        df['MONTH'] = months 
        #next, cleanse the dataset of rows we dont want
        df = self.cleanseData(df)

        #next, calculate the flight ranks using my own model to determine what is the best flight. append the flight rank to a success rate column
        df = self.calculateRanks(df)
        self.df = df
        df.to_csv("engineered.csv")

        return df
        
    def cleanseData(self,DF):
        DF = DF[DF.CLASS == 'F']    
        DF = DF[DF.SEATS != 0]
        DF = DF[DF.PASSENGERS != 0]
       # DF.corr().to_csv("test.csv")
        return DF 



FlightProgram()
